# Коллекция (Иттерибл, последовательности пока это всё синонемы)
#
# Список (list)
# списки в других языках это массива
# Список - это упорядоченная коллекция различных типов (может, быть большим, маленьким, можем хранить любой тип данных)
# работают срезы
# a = [1, 2, 3, 4]
# print(a[1:3])
# Создание спика:
# 1) number = [2, 4, 8, 10, 12], words = ['hello', "python"]
# print(words[1][2]) = t
# a = [1, 2, 3, "Hello"]
# print(a[3][2])
# 2) Приведение типов (каждый элемент)
# a = 'hiy'
# print(list(a))
# b = [i**2 for i in range(1, 10)]
# print(b)
# l = list('llo') = ['l', 'l', 'o']
# 3) лист кампрехешн (генератор списков)
# numbers  = [i**2 for i in range(1,101)]
#
# words[1] = 'dfcz' - изменение списка
number = [2, 4, 8, 10, 12]
# number[4] = "hi"
# del number[2]
# del number[0:2]
# print(number)
# a = number.pop(2)
# number.pop()
# number.remove(12)
# print(number, sep=', ')
# del words[0] - удаление индекса
# del numbers[1:3] - удаление по срезу
# нельзя указывать недействительный индекс, даст ошибку
# numbers = [1, 2, 4, 10]
# # numbers.pop(1) - вырезается, если индекс не указан, удалится последнее значение
# numbers.remove(4) - удаляет только первое вхождение
# Проверка на вхождение
# in or not in
# Добавление в список:
# .append(1 аргумен) - добавляет в конец
# добавление по индексу
# .insert(1 аргрумент индекс, 2 аргумент что)
# a = [1, 2, 3, 4]
# # a.append(5)
# # a.insert(2, "hello")
# print(a)
# добавление в конец всегда быстрее (за одно и тоже время), от единицы скорость выполннеия
# .extend() - передаем строго итербл последовательность
# если в документации сказано, что возвращается None, то ни к чему не нужно присвавать переменную, значит он изменяет сам объект
# a = [1, 2, 3]
# a.extend({'he': 1, 'age': 5})
# print(a)
# Списки можно складывать только со списками
# a = [1, 2 ,3]
# b = [5, 5 ,7]
# print(a+b)
# Списки можно умножать на число
# print([1, 2]*4)
# Поиски по спискам
# list.index(значение, старт, конец) - если значения нет, выдаст ошибку
# a = [1, 2, 3, 2]
# b = a.index(3)
# print(b)
# # list.count(значение) - сколько указанного значения в списке
# b = a.count(2)
# print(b)
# Сортировка - пока мы можем сортировать списки только с одинаковыми типами данных
# numbers = [5, 3, 6, 4]
# # numbers.sort(reverse= True) - без аргументов сортировка по пордку, аргумент reverse= True меняет направление
# numbers.sort(reverse=True)
# print(numbers)
# print(sorted(numbers, reverse=True))

# sorted(numbers, reverse= True) - фунция sorted() создает копию, на основной список не влияет
#
# list.reverse() - меняет основной список (разворачивает)
# list[::-1] - меняет копию
# numbers.sort()
# numbers.reverse()
# a = numbers[::-1]
# print(numbers)
# print(a)
# Очистка метод .clear
#
# Копирование
# a = b - так можно копировать только в неизменяемых типах данных
# 1) метод .copy
# 2) срез от начало до конца [:]
# это всё поверхостное копирование
#
# a = [1, 2, 3]
# b = [1, 2, 3]
# print(a == b, a is b, a[0] is b[0], id(a), id(b))
# Списки дорогой по памяти


# КОРТЕЖИ - по факту это неизменяемый список
# создание кортежа
# 1) синтаксический сахар с помощью скобок (), синтаксически можно без скобок
# 2)Приведение типов Tuple
#
# Можно складывать, можно сравнивать, обращаться по индексу
# может быть хэшебл и не хэшебл, если внутри хэшибл объеткы, то он хэшбл и наоборот
# a = 1, 2, 4, 4
# b = (5, 5, 1)
# print(a.index(1))
# изминяемые объеты можно изменить в неизменяемом объектe, изменяется объект но не ссылка
# a = (1, 2, [1, 2])
# print(id(a))
# a[2].append(4)
# print(a)
# print(id(a))
# корежи дешевле по памяти, и поиск по кортежам дешевле по поиску
# кортеж употрябляет 1 ячейку в оперативке, а список 2

# Множества
# Круги эллера
# Множество хранит только уникальные экземляры
# элементами могут быть только хэшбл объекты
# a = {2, 3, True}
# b = {2}
# c = True, False
# a = set("hello") - любой иттербл объект
# print(a.isdisjoint(b))  #- #проверка на то, что это не пересекающиеся последовательности
# print(b.issubset(a))
# print(b<=a)
# a.add(55)
# b.pop()
# c = a.union(b, "he")
# d = a | b | {'hello'}
# print(a.difference(b, c))
# print(a-b)
# print(a.symmetric_difference(b))
# print(a)
import collections
a = dict([("hello", 15), ('жопка', 15)])
# print(a)
# print(a.get('helloй', 'блин'))
# print(a['helloq'])
# b = a.popitem()
# print(a.values())
# print(a.keys())
# print(a.items())
text = 'Hello'
data = collections.Counter(text)
print(list(data.elements()))






# print(a.issuperset(b))





